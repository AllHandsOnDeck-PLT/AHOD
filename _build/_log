### Starting build.
# Target: AHOD.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:AHOD.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules AHOD.ml > AHOD.ml.depends
# Target: codegen.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:codegen.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules codegen.ml > codegen.ml.depends
# Target: ast.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:ast.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules ast.ml > ast.ml.depends
# Target: sast.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:sast.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules sast.ml > sast.ml.depends
# Target: ast.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:ast.cmo, file:ast.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o ast.cmo ast.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o ast.cmo ast.ml
File "ast.ml", lines 75-83, characters 24-18:
75 | ........................function
76 |     Int -> "int"
77 |   | Bool -> "bool"
78 |   | Float -> "float"
79 |   | String -> "string"
80 |   | None -> "none"
81 |   | Series x -> "series<" ^ (string_of_typ x) ^ ">"
82 |   | Player -> "player"
83 |   | Card -> "card"
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ClassID
File "ast.ml", lines 85-99, characters 25-16:
85 | .........................function
86 |     Iliteral(l) -> string_of_int l
87 |   | Fliteral(l) -> l
88 |   | Bliteral(true) -> "true"
89 |   | Bliteral(false) -> "false"
...
96 |   | Assign(v, e) -> v ^ " = " ^ string_of_expr e
97 |   | ActionCall(f, el) ->
98 |     "do " ^ f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
99 |   | Noexpr -> ""
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(PlayerClassCall _|CClassCall _|AttrCall (_, _))
# Target: sast.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:sast.cmo, file:sast.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o sast.cmo sast.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o sast.cmo sast.ml
File "sast.ml", lines 54-69, characters 34-11:
54 | ..................................(match e with
55 |     SIliteral(l) -> string_of_int l
56 |   | SFliteral(l) -> l
57 |   | SBliteral(true) -> "true"
58 |   | SBliteral(false) -> "false"
...
66 |   | SActionCall(f, el) ->
67 |     "do " ^f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
68 |   | SNoexpr -> ""
69 |           )........
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SClassCall (_, _)|SPlayerClassCall _|SAttrCall (_, _))
# Target: parse.mly, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mly, file:parse.mly, infer, ocaml, ocamlyacc, parser, quiet, traverse }
/Users/maradimofte/.opam/default/bin/ocamlyacc parse.mly
+ /Users/maradimofte/.opam/default/bin/ocamlyacc parse.mly
8 rules never reduced
# Target: parse.mli.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mli, file:parse.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules parse.mli > parse.mli.depends
# Target: scanner.mll, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mll, file:scanner.mll, lexer, ocaml, ocamllex, quiet, traverse }
/Users/maradimofte/.opam/default/bin/ocamllex.opt -q scanner.mll
# Target: scanner.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:scanner.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules scanner.ml > scanner.ml.depends
# Target: parse.cmi, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:mli, file:parse.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o parse.cmi parse.mli
# Target: semant.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:semant.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules semant.ml > semant.ml.depends
# Target: codegen.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:codegen.cmo, file:codegen.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o codegen.cmo codegen.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o codegen.cmo codegen.ml
File "codegen.ml", lines 29-36, characters 26-27:
29 | ..........................function
30 |     | A.Int   -> i32_t
31 |     | A.Bool  -> i1_t 
32 |     | A.Float -> float_t
33 |     | A.String -> string_t
34 |     | A.None -> void_t
35 |     | A.Series t -> series_t (ltype_of_typ t)
36 |     | A.ClassID -> player_t.
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Player|Card)
File "codegen.ml", lines 229-238, characters 2-3:
229 | ..(match fst e with 
230 | 		A.String -> L.build_call printf_func [| L.const_in_bounds_gep str_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|] ; (expr builder e) |]
231 | 		"printf" builder
232 | 		| A.Int -> L.build_call printf_func [| L.const_in_bounds_gep int_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|]  ; (expr builder e) |]
233 | 		"printf" builder
234 | 		| A.Float -> L.build_call printf_func [| L.const_in_bounds_gep float_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|]  ; (expr builder e) |]
235 | 		"printf" builder
236 | 		| A.Bool -> L.build_call printf_func [| L.const_in_bounds_gep bool_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|]  ; (expr builder e) |]
237 | 		"printf" builder
238 | 		)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(None|ClassID|Player|Card|Series _)
File "codegen.ml", lines 242-255, characters 4-5:
242 | ....(match op with 
243 |       A.Add     -> L.build_fadd
244 |     | A.Sub     -> L.build_fsub
245 |     | A.Mult    -> L.build_fmul
246 |     | A.Div     -> L.build_fdiv 
...
252 |     | A.Geq     -> L.build_fcmp L.Fcmp.Oge
253 |     | A.And | A.Or ->
254 |         raise (Failure "internal error: semant should have rejected and/or on float")
255 |     )......................
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Mod
File "codegen.ml", lines 259-272, characters 4-5:
259 | ....(match op with
260 |       A.Add     -> L.build_add
261 |     | A.Sub     -> L.build_sub
262 |     | A.Mult    -> L.build_mul
263 |     | A.Div     -> L.build_sdiv
...
269 |     | A.Leq     -> L.build_icmp L.Icmp.Sle
270 |     | A.Greater -> L.build_icmp L.Icmp.Sgt
271 |     | A.Geq     -> L.build_icmp L.Icmp.Sge
272 |     )......................
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Mod
File "codegen.ml", lines 192-306, characters 40-126:
192 | ........................................match e with
193 | 	SSliteral s   -> L.build_global_stringptr s "str" builder
194 | 	| SBliteral b -> L.const_int i1_t (if b then 1 else 0)
195 | 	| SIliteral i -> L.const_int i32_t i 
196 |   | SFliteral f -> L.const_float_of_string float_t f
...
303 |       L.build_load new_class_ptr "new_class" builder
304 |             (* ======================================================= *)*)
305 |   | SSeriesGet (series_type, id, e) ->
306 |       L.build_call (StringMap.find (type_str series_type) series_get) [| (lookup id); (expr builder e) |] "series_get" builder.
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SActionCall ("PRINT", _::_::_)
File "codegen.ml", lines 319-356, characters 23-68:
319 | .......................function
320 | 	| SBlock stmt_list -> List.fold_left stmt builder stmt_list 
321 |   | SExpr e -> ignore(expr builder e); builder
322 |   | SSeriesAdd (id, e) -> 
323 |       ignore(L.build_call (StringMap.find (type_str (fst e)) series_add) [| (lookup id); (expr builder e) |] "" builder); builder 
...
353 | 
354 |       (* Implement for loops as while loops *)
355 |       | SFor (e1, e2, e3, body) -> stmt builder
356 |       ( SBlock [SExpr e1 ; SWhile (e2, SBlock [body ; SExpr e3]) ] )
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SReturn _|SForLit (_, _, _))
File "codegen.ml", line 4, characters 0-12:
4 | open Hashtbl
    ^^^^^^^^^^^^
Warning 33 [unused-open]: unused open Stdlib.Hashtbl.
File "codegen.ml", line 8, characters 24-36:
8 | let translate (globals, action_decls, main_stmt) =
                            ^^^^^^^^^^^^
Warning 27 [unused-var-strict]: unused variable action_decls.
File "codegen.ml", line 74, characters 9-19:
74 |      let init_class builder class_struct_ptr class_type = 
              ^^^^^^^^^^
Warning 26 [unused-var]: unused variable init_class.
# Target: scanner.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:scanner.cmo, file:scanner.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o scanner.cmo scanner.ml
# Target: semant.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:semant.cmo, file:semant.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o semant.cmo semant.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o semant.cmo semant.ml
File "semant.ml", line 1, characters 0-8:
1 | open Ast
    ^^^^^^^^
Warning 45 [open-shadow-label-constructor]: this open statement shadows the constructor None (which is later used)
File "semant.ml", lines 34-78, characters 22-61:
34 | ......................function
35 | 		(*need to figure out typ, if name is defined*)
36 |     | PlayerClassCall(pparams) ->  (Player, SPlayerClassCall(List.map check_expr pparams))
37 | 		| ActionCall(aname, aparams) -> (String, SActionCall(aname, List.map check_expr aparams))
38 | 		| Sliteral s -> (String, SSliteral(s))
...
75 |              Int -> Int
76 |              | _ -> raise (Failure ("list_get index must be integer, not " ^ string_of_typ t)) 
77 |          in let list_type = check_list_type var
78 |          in (list_type, SSeriesGet(list_type, var, (ty, e')))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(CClassCall _|AttrCall (_, _))
File "semant.ml", lines 86-96, characters 22-39:
86 | ......................function
87 | 		Expr e -> SExpr (check_expr e) 
88 |     | SeriesAdd (var, e) -> 
89 |         let _ = check_list_type var in
90 |         SSeriesAdd(var, check_match_list_type_expr var e) 
...
93 |     | For(e1, e2, e3, st) ->
94 |       SFor(check_expr e1, check_expr e2, check_expr e3, check_stmt st)
95 |     | Block sl -> 
96 |          SBlock(List.map check_stmt sl)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Return _|ForLit (_, _, _))
File "semant.ml", line 6, characters 20-32:
6 | let check (globals, action_decls, main_stmt) =
                        ^^^^^^^^^^^^
Warning 27 [unused-var-strict]: unused variable action_decls.
File "semant.ml", line 44, characters 6-26:
44 |     | Assign(var, e) as ex -> 
           ^^^^^^^^^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable ex.
File "semant.ml", line 50, characters 6-28:
50 |     | Binop(e1, op, e2) as e -> 
           ^^^^^^^^^^^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable e.
# Target: AHOD.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:AHOD.cmo, file:AHOD.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -o AHOD.cmo AHOD.ml
# Target: ast.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:ast.cmx, file:ast.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o ast.cmx ast.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o ast.cmx ast.ml
File "ast.ml", lines 75-83, characters 24-18:
75 | ........................function
76 |     Int -> "int"
77 |   | Bool -> "bool"
78 |   | Float -> "float"
79 |   | String -> "string"
80 |   | None -> "none"
81 |   | Series x -> "series<" ^ (string_of_typ x) ^ ">"
82 |   | Player -> "player"
83 |   | Card -> "card"
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ClassID
File "ast.ml", lines 85-99, characters 25-16:
85 | .........................function
86 |     Iliteral(l) -> string_of_int l
87 |   | Fliteral(l) -> l
88 |   | Bliteral(true) -> "true"
89 |   | Bliteral(false) -> "false"
...
96 |   | Assign(v, e) -> v ^ " = " ^ string_of_expr e
97 |   | ActionCall(f, el) ->
98 |     "do " ^ f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
99 |   | Noexpr -> ""
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(PlayerClassCall _|CClassCall _|AttrCall (_, _))
# Target: sast.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:sast.cmx, file:sast.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o sast.cmx sast.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o sast.cmx sast.ml
File "sast.ml", lines 54-69, characters 34-11:
54 | ..................................(match e with
55 |     SIliteral(l) -> string_of_int l
56 |   | SFliteral(l) -> l
57 |   | SBliteral(true) -> "true"
58 |   | SBliteral(false) -> "false"
...
66 |   | SActionCall(f, el) ->
67 |     "do " ^f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
68 |   | SNoexpr -> ""
69 |           )........
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SClassCall (_, _)|SPlayerClassCall _|SAttrCall (_, _))
# Target: parse.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:parse.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules parse.ml > parse.ml.depends
# Target: parse.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:parse.cmx, file:parse.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o parse.cmx parse.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o parse.cmx parse.ml
File "parse.mly", line 2, characters 0-8:
Warning 45 [open-shadow-label-constructor]: this open statement shadows the constructor None (which is later used)
File "parse.mly", line 2, characters 0-8:
Warning 45 [open-shadow-label-constructor]: this open statement shadows the label actions (which is later used)
File "parse.mly", line 4, characters 4-8:
Warning 32 [unused-value-declaration]: unused value frst.
File "parse.mly", line 5, characters 4-8:
Warning 32 [unused-value-declaration]: unused value scnd.
File "parse.mly", line 6, characters 4-7:
Warning 32 [unused-value-declaration]: unused value trd.
# Target: codegen.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:codegen.cmx, file:codegen.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o codegen.cmx codegen.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o codegen.cmx codegen.ml
File "codegen.ml", lines 29-36, characters 26-27:
29 | ..........................function
30 |     | A.Int   -> i32_t
31 |     | A.Bool  -> i1_t 
32 |     | A.Float -> float_t
33 |     | A.String -> string_t
34 |     | A.None -> void_t
35 |     | A.Series t -> series_t (ltype_of_typ t)
36 |     | A.ClassID -> player_t.
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Player|Card)
File "codegen.ml", lines 229-238, characters 2-3:
229 | ..(match fst e with 
230 | 		A.String -> L.build_call printf_func [| L.const_in_bounds_gep str_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|] ; (expr builder e) |]
231 | 		"printf" builder
232 | 		| A.Int -> L.build_call printf_func [| L.const_in_bounds_gep int_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|]  ; (expr builder e) |]
233 | 		"printf" builder
234 | 		| A.Float -> L.build_call printf_func [| L.const_in_bounds_gep float_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|]  ; (expr builder e) |]
235 | 		"printf" builder
236 | 		| A.Bool -> L.build_call printf_func [| L.const_in_bounds_gep bool_format_str [|L.const_int i32_t 0; L.const_int i32_t 0|]  ; (expr builder e) |]
237 | 		"printf" builder
238 | 		)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(None|ClassID|Player|Card|Series _)
File "codegen.ml", lines 242-255, characters 4-5:
242 | ....(match op with 
243 |       A.Add     -> L.build_fadd
244 |     | A.Sub     -> L.build_fsub
245 |     | A.Mult    -> L.build_fmul
246 |     | A.Div     -> L.build_fdiv 
...
252 |     | A.Geq     -> L.build_fcmp L.Fcmp.Oge
253 |     | A.And | A.Or ->
254 |         raise (Failure "internal error: semant should have rejected and/or on float")
255 |     )......................
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Mod
File "codegen.ml", lines 259-272, characters 4-5:
259 | ....(match op with
260 |       A.Add     -> L.build_add
261 |     | A.Sub     -> L.build_sub
262 |     | A.Mult    -> L.build_mul
263 |     | A.Div     -> L.build_sdiv
...
269 |     | A.Leq     -> L.build_icmp L.Icmp.Sle
270 |     | A.Greater -> L.build_icmp L.Icmp.Sgt
271 |     | A.Geq     -> L.build_icmp L.Icmp.Sge
272 |     )......................
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Mod
File "codegen.ml", lines 192-306, characters 40-126:
192 | ........................................match e with
193 | 	SSliteral s   -> L.build_global_stringptr s "str" builder
194 | 	| SBliteral b -> L.const_int i1_t (if b then 1 else 0)
195 | 	| SIliteral i -> L.const_int i32_t i 
196 |   | SFliteral f -> L.const_float_of_string float_t f
...
303 |       L.build_load new_class_ptr "new_class" builder
304 |             (* ======================================================= *)*)
305 |   | SSeriesGet (series_type, id, e) ->
306 |       L.build_call (StringMap.find (type_str series_type) series_get) [| (lookup id); (expr builder e) |] "series_get" builder.
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
SActionCall ("PRINT", _::_::_)
File "codegen.ml", lines 319-356, characters 23-68:
319 | .......................function
320 | 	| SBlock stmt_list -> List.fold_left stmt builder stmt_list 
321 |   | SExpr e -> ignore(expr builder e); builder
322 |   | SSeriesAdd (id, e) -> 
323 |       ignore(L.build_call (StringMap.find (type_str (fst e)) series_add) [| (lookup id); (expr builder e) |] "" builder); builder 
...
353 | 
354 |       (* Implement for loops as while loops *)
355 |       | SFor (e1, e2, e3, body) -> stmt builder
356 |       ( SBlock [SExpr e1 ; SWhile (e2, SBlock [body ; SExpr e3]) ] )
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SReturn _|SForLit (_, _, _))
File "codegen.ml", line 4, characters 0-12:
4 | open Hashtbl
    ^^^^^^^^^^^^
Warning 33 [unused-open]: unused open Stdlib.Hashtbl.
File "codegen.ml", line 8, characters 24-36:
8 | let translate (globals, action_decls, main_stmt) =
                            ^^^^^^^^^^^^
Warning 27 [unused-var-strict]: unused variable action_decls.
File "codegen.ml", line 74, characters 9-19:
74 |      let init_class builder class_struct_ptr class_type = 
              ^^^^^^^^^^
Warning 26 [unused-var]: unused variable init_class.
# Target: scanner.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:scanner.cmx, file:scanner.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o scanner.cmx scanner.ml
# Target: semant.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:semant.cmx, file:semant.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o semant.cmx semant.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o semant.cmx semant.ml
File "semant.ml", line 1, characters 0-8:
1 | open Ast
    ^^^^^^^^
Warning 45 [open-shadow-label-constructor]: this open statement shadows the constructor None (which is later used)
File "semant.ml", lines 34-78, characters 22-61:
34 | ......................function
35 | 		(*need to figure out typ, if name is defined*)
36 |     | PlayerClassCall(pparams) ->  (Player, SPlayerClassCall(List.map check_expr pparams))
37 | 		| ActionCall(aname, aparams) -> (String, SActionCall(aname, List.map check_expr aparams))
38 | 		| Sliteral s -> (String, SSliteral(s))
...
75 |              Int -> Int
76 |              | _ -> raise (Failure ("list_get index must be integer, not " ^ string_of_typ t)) 
77 |          in let list_type = check_list_type var
78 |          in (list_type, SSeriesGet(list_type, var, (ty, e')))
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(CClassCall _|AttrCall (_, _))
File "semant.ml", lines 86-96, characters 22-39:
86 | ......................function
87 | 		Expr e -> SExpr (check_expr e) 
88 |     | SeriesAdd (var, e) -> 
89 |         let _ = check_list_type var in
90 |         SSeriesAdd(var, check_match_list_type_expr var e) 
...
93 |     | For(e1, e2, e3, st) ->
94 |       SFor(check_expr e1, check_expr e2, check_expr e3, check_stmt st)
95 |     | Block sl -> 
96 |          SBlock(List.map check_stmt sl)
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Return _|ForLit (_, _, _))
File "semant.ml", line 6, characters 20-32:
6 | let check (globals, action_decls, main_stmt) =
                        ^^^^^^^^^^^^
Warning 27 [unused-var-strict]: unused variable action_decls.
File "semant.ml", line 44, characters 6-26:
44 |     | Assign(var, e) as ex -> 
           ^^^^^^^^^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable ex.
File "semant.ml", line 50, characters 6-28:
50 |     | Binop(e1, op, e2) as e -> 
           ^^^^^^^^^^^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable e.
# Target: AHOD.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:AHOD.cmx, file:AHOD.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -o AHOD.cmx AHOD.ml
# Target: AHOD.native, tags: { package(llvm), package(llvm.analysis), warn(+a-4), dont_link_with, extension:native, file:AHOD.native, link, native, ocaml, program, quiet, traverse }
ocamlfind ocamlopt -linkpkg -package llvm -package llvm.analysis ast.cmx sast.cmx codegen.cmx parse.cmx scanner.cmx semant.cmx AHOD.cmx -o AHOD.native
# Compilation successful.
